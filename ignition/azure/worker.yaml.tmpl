storage:
  files:
    - path: /etc/kubernetes/config/azure.yaml
      filesystem: root
      mode: 0600
      contents: 
        inline: |
          cloud: ${AZURE_CLOUD}
          tenantId: ${AZURE_SP_TENANTID}
          subscriptionId: ${AZURE_SP_SUBSCRIPTIONID}
          aadClientId: ${AZURE_SP_AADCLIENTID}
          aadClientSecret: ${AZURE_SP_AADCLIENTSECRET}
          resourceGroup: ${AZURE_RESOURCEGROUP}
          location: ${AZURE_LOCATION}
          subnetName: ${AZURE_SUBNETNAME}
          securityGroupName: ${AZURE_SECGROUPNAME}
          vnetName: ${AZURE_VNETNAME}
          routeTableName: ${AZURE_ROUTETABLE}
    - path: /etc/kubernetes/config/proxy-kubeconfig.yaml
      filesystem: root
      mode: 0644
      contents:
        inline:  |
          apiVersion: v1
          kind: Config
          users:
          - name: proxy
            user:
            client-certificate: /etc/kubernetes/ssl/worker-crt.pem
            client-key: /etc/kubernetes/ssl/worker-key.pem
          clusters:
          - name: local
            cluster:
              certificate-authority: /etc/kubernetes/ssl/worker-ca.pem
              server: https://${API_DOMAIN_NAME}
          contexts:
          - context:
              cluster: local
              user: proxy
            name: service-account-context
          current-context: service-account-context
    - path: /etc/kubernetes/config/kubelet-kubeconfig.yaml
      filesystem: root
      mode: 0644
      contents: 
        inline: |
          apiVersion: v1
          kind: Config
          users:
          - name: kubelet
            user:
              client-certificate: /etc/kubernetes/ssl/worker-crt.pem
              client-key: /etc/kubernetes/ssl/worker-key.pem
          clusters:
          - name: local
            cluster:
              certificate-authority: /etc/kubernetes/ssl/worker-ca.pem
              server: https://${API_DOMAIN_NAME}
          contexts:
          - context:
              cluster: local
              user: kubelet
            name: service-account-context
          current-context: service-account-context
    - path: /opt/wait-for-domains
      filesystem: root
      mode: 0544
      contents: 
        inline: |
          #!/bin/bash
          domains="${ETCD_DOMAIN_NAME} ${API_DOMAIN_NAME} ${VAULT_DOMAIN_NAME}"

          for domain in $domains; do
            until nslookup $domain; do
                echo "Waiting for domain $domain to be available"
                sleep 5
            done

            echo "Successfully resolved domain $domain"
          done

    - path: /etc/tokens/node
      filesystem: root
      owner: root
      mode: 0400
      contents:
        inline:  |
          VAULT_TOKEN=${G8S_VAULT_TOKEN}

    - path: /etc/ssh/sshd_config
      filesystem: root
      mode: 0600
      contents:
        inline:  |
          # Use most defaults for sshd configuration.
          UsePrivilegeSeparation sandbox
          Subsystem sftp internal-sftp
          ClientAliveInterval 180
          UseDNS no
          UsePAM yes
          PrintLastLog no # handled by PAM
          PrintMotd no # handled by PAM
          # Non defaults (#100)
          ClientAliveCountMax 2
          PasswordAuthentication no
          TrustedUserCAKeys /etc/ssh/trusted-user-ca-keys.pem

    - path: /opt/get-ca.sh
      filesystem: root
      mode: 0770
      contents:
        inline:  |
          #!/bin/bash

          if [ -z "$1" ] || [ -z "$2" ]
          then
                  echo "Insufficient number of args"
                  echo "$0 <ive_ip_address>:<port> <output_file>"
                  exit
          fi
          echo Connecting to $1
          echo -n | openssl s_client -showcerts -connect $1 2>err.txt 1>out.txt
          if [ "$?" -ne "0" ]
          then
                  cat err.txt
                  exit
          fi
          echo -n Generating Certificate
          grep -in "\-----.*CERTIFICATE-----"  out.txt | cut -f 1 -d ":" 1> out1.txt
          let start_line=`tail -n 2 out1.txt | head -n 1`
          let end_line=`tail -n 1 out1.txt`
          if [ -z "$start_line" ]
          then
                  echo "error"
                  exit
          fi
          let nof_lines=$end_line-$start_line+1
          #echo "from $start_line to $end_line total lines $nof_lines"
          echo -n " .... "
          head -n $end_line out.txt | tail -n $nof_lines 1> out1.txt
          openssl x509 -in out1.txt -outform pem -out $2
          echo done.
          rm out.txt out1.txt err.txt

    - path: /etc/sysctl.d/hardening.conf
      filesystem: root
      mode: 0600
      contents: 
        inline: |
          kernel.kptr_restrict = 2
          kernel.sysrq = 0
          net.ipv4.conf.all.send_redirects = 0
          net.ipv4.conf.default.accept_redirects = 0
          net.ipv4.tcp_timestamps = 0
          net.ipv6.conf.all.accept_redirects = 0
          net.ipv6.conf.default.accept_redirects = 0

    - path: /etc/audit/rules.d/10-docker.rules
      filesystem: root
      mode: 0644
      contents:
        inline:  |
          -w /usr/bin/docker -k docker
          -w /var/lib/docker -k docker
          -w /etc/docker -k docker
          -w /etc/systemd/system/docker.service.d/10-giantswarm-extra-args.conf -k docker
          -w /etc/systemd/system/docker.service.d/01-wait-docker.conf -k docker
          -w /usr/lib/systemd/system/docker.service -k docker
          -w /usr/lib/systemd/system/docker.socket -k docker

    - path: /etc/systemd/system/audit-rules.service.d/10-Wait-For-Docker.conf
      filesystem: root
      mode: 0644
      contents:
        inline:  |
          [Service]
          ExecStartPre=/bin/bash -c "while [ ! -f /etc/audit/rules.d/10-docker.rules ]; do echo 'Waiting for /etc/audit/rules.d/10-docker.rules to be written' && sleep 1; done"

systemd:
  units:
  - name: update-engine.service
    enabled: false
    mask: true
  - name: locksmithd.service
    enabled: false
    mask: true
  - name: etcd2.service
    enabled: false
    mask: true
  - name: fleet.service
    enabled: false
    mask: true
  - name: fleet.socket
    enabled: false
    mask: true
  - name: flanneld.service
    enabled: false
    mask: true
  - name: systemd-networkd-wait-online.service
    enabled: false
    mask: true
  - name: var-lib-docker.mount
    enabled: true
    contents: |
      [Unit]
      Description=Mount disk to /var/lib/docker
      Before=docker.service

      [Mount]
      What=/dev/disk/by-label/docker
      Where=/var/lib/docker
      Type=xfs
   
      [Install]
      WantedBy=local-fs.targer
  - name: wait-for-domains.service
    enabled: true
    contents: |
      [Unit]
      Description=Wait for etcd and k8s API domains to be available

      [Service]
      Type=oneshot
      ExecStart=/opt/wait-for-domains

      [Install]
      WantedBy=multi-user.target
  - name: os-hardening.service
    enabled: true
    contents: |
      [Unit]
      Description=Apply os hardening

      [Service]
      Type=oneshot
      ExecStartPre=-/bin/bash -c "gpasswd -d core rkt; gpasswd -d core docker; gpasswd -d core wheel"
      ExecStartPre=/bin/bash -c "until [ -f '/etc/sysctl.d/hardening.conf' ]; do echo Waiting for sysctl file; sleep 1s;done;"
      ExecStart=/usr/sbin/sysctl -p /etc/sysctl.d/hardening.conf

      [Install]
      WantedBy=multi-user.target
  - name: get-vault-ca.service
    enabled: true
    contents: |
      [Unit]
      Description=get vault-ca into trusted certs
      Before=calico-certs.service kubelet-certs.service
      After=wait-for-domains.service

      [Service]
      Type=oneshot
      ExecStartPre=/opt/get-ca.sh ${VAULT_DOMAIN_NAME}:443 /etc/ssl/certs/gs-ca.pem
      ExecStart=/sbin/update-ca-certificates
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target
  - name: docker.service
    enabled: true
    dropins:
    - name: 10-giantswarm-extra-args.conf
      contents: |
        [Unit]
        Requires=var-lib-docker.mount
        After=var-lib-docker.mount

        [Service]
        Environment="DOCKER_CGROUPS=--exec-opt native.cgroupdriver=cgroupfs --log-opt max-size=50m --log-opt max-file=2 --log-opt labels=io.kubernetes.container.hash,io.kubernetes.container.name,io.kubernetes.pod.name,io.kubernetes.pod.namespace,io.kubernetes.pod.uid"
        Environment="DOCKER_OPT_BIP=--bip=${DOCKER_CIDR}"
        Environment="DOCKER_OPTS=--live-restore --userland-proxy=false --icc=false"
  - name: k8s-setup-network-env.service
    enabled: true
    contents: |
      [Unit]
      Description=k8s-setup-network-env Service
      Wants=network.target docker.service
      After=network.target docker.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      TimeoutStartSec=0
      Environment="IMAGE=quay.io/giantswarm/k8s-setup-network-environment:1f4ffc52095ac368847ce3428ea99b257003d9b9"
      Environment="NAME=%p.service"
      Environment="NETWORK_CONFIG_CONTAINER="
      ExecStartPre=/usr/bin/docker pull $IMAGE
      ExecStartPre=-/usr/bin/docker stop -t 10 $NAME
      ExecStartPre=-/usr/bin/docker rm -f $NAME
      ExecStart=/usr/bin/docker run --rm --net=host -v /etc:/etc --name $NAME $IMAGE
      ExecStop=-/usr/bin/docker stop -t 10 $NAME
      ExecStopPost=-/usr/bin/docker rm -f $NAME

      [Install]
      WantedBy=multi-user.target
  - name: calico-certs.service
    enabled: true
    contents: |
      [Unit]
      Description=gen etcd client certs for calico
      Requires=get-vault-ca.service k8s-setup-network-env.service docker.service wait-for-domains.service waagent.service
      After=get-vault-ca.service k8s-setup-network-env.service docker.service wait-for-domains.service waagent.service

      [Service]
      EnvironmentFile=/etc/environment
      EnvironmentFile=/etc/network-environment
      EnvironmentFile=/etc/tokens/node
      Type=oneshot
      RemainAfterExit=yes
      ExecStartPre=/usr/bin/mkdir -p /etc/kubernetes/ssl/etcd/
      ExecStart=/usr/bin/docker run \
      --net=host \
      -v /etc/ssl/certs/ca-certificates.crt:/etc/ssl/certs/ca-certificates.crt \
      -v /etc/kubernetes/ssl/etcd/:/etc/kubernetes/ssl/etcd/ \
      quay.io/giantswarm/certctl:b07d0913d5cb369a6b605394bdd4be4633451be9 \
      issue \
      --vault-addr=https://${VAULT_DOMAIN_NAME} \
      --vault-token=$${VAULT_TOKEN} \
      --cluster-id=g8s \
      --common-name=${ETCD_DOMAIN_NAME} \
      --ttl=8760h \
      --crt-file=/etc/kubernetes/ssl/etcd/client-crt.pem \
      --ip-sans=127.0.0.1,${DEFAULT_IPV4} \
      --alt-names=localhost \
      --key-file=/etc/kubernetes/ssl/etcd/client-key.pem \
      --ca-file=/etc/kubernetes/ssl/etcd/client-ca.pem
      ExecStop=/usr/bin/rm -rf /etc/kubernetes/ssl/etcd/

      [Install]
      WantedBy=multi-user.target
  - name: k8s-proxy.service
    enabled: true
    contents: |
      [Unit]
      Description=k8s-proxy
      StartLimitIntervalSec=0
      After=kubelet-certs.service
      Requires=kubelet-certs.service

      [Service]
      Restart=always
      RestartSec=0
      TimeoutStopSec=10
      EnvironmentFile=/etc/network-environment
      Environment="IMAGE=quay.io/giantswarm/hyperkube:v1.10.2"
      Environment="NAME=%p.service"
      Environment="NETWORK_CONFIG_CONTAINER="
      ExecStartPre=/usr/bin/docker pull $IMAGE
      ExecStartPre=-/usr/bin/docker stop -t 10 $NAME
      ExecStartPre=-/usr/bin/docker rm -f $NAME
      ExecStartPre=/bin/bash -c "while [ ! -f /etc/kubernetes/ssl/worker-ca.pem ]; do echo 'Waiting for /etc/kubernetes/ssl/worker-ca.pem to be written' && sleep 1; done"
      ExecStartPre=/bin/bash -c "while [ ! -f /etc/kubernetes/ssl/worker-crt.pem ]; do echo 'Waiting for /etc/kubernetes/ssl/worker-crt.pem to be written' && sleep 1; done"
      ExecStartPre=/bin/bash -c "while [ ! -f /etc/kubernetes/ssl/worker-key.pem ]; do echo 'Waiting for /etc/kubernetes/ssl/worker-key.pem to be written' && sleep 1; done"
      ExecStartPre=/bin/sh -c "while ! curl --output /dev/null --silent --head --fail --cacert /etc/kubernetes/ssl/worker-ca.pem --cert /etc/kubernetes/ssl/worker-crt.pem --key /etc/kubernetes/ssl/worker-key.pem https://${API_DOMAIN_NAME}; do sleep 1 && echo 'Waiting for master'; done"
      ExecStart=/bin/sh -c "/usr/bin/docker run --rm --net=host --privileged=true \
      --name $NAME \
      -v /usr/share/ca-certificates:/etc/ssl/certs \
      -v /etc/kubernetes/ssl/:/etc/kubernetes/ssl/ \
      -v /etc/kubernetes/config/:/etc/kubernetes/config/ \
      $IMAGE \
      /hyperkube proxy \
      --master=https://${API_DOMAIN_NAME} \
      --proxy-mode=iptables \
      --logtostderr=true \
      --kubeconfig=/etc/kubernetes/config/proxy-kubeconfig.yaml \
      --v=2"
      ExecStop=-/usr/bin/docker stop -t 10 $NAME
      ExecStopPost=-/usr/bin/docker rm -f $NAME

      [Install]
      WantedBy=multi-user.target
  - name: kubelet-certs.service
    enabled: true
    contents: |
      [Unit]
      Description=api-certs
      Requires=get-vault-ca.service k8s-setup-network-env.service docker.service wait-for-domains.service waagent.service
      After=get-vault-ca.service k8s-setup-network-env.service docker.service wait-for-domains.service waagent.service

      [Service]
      EnvironmentFile=/etc/environment
      EnvironmentFile=/etc/network-environment
      EnvironmentFile=/etc/tokens/node
      Type=oneshot
      RemainAfterExit=yes
      ExecStartPre=/usr/bin/mkdir -p /etc/kubernetes/ssl/
      ExecStart=/usr/bin/docker run \
      --net=host \
      -v /etc/ssl/certs/ca-certificates.crt:/etc/ssl/certs/ca-certificates.crt \
      -v /etc/kubernetes/ssl/:/etc/kubernetes/ssl/ \
      quay.io/giantswarm/certctl:b07d0913d5cb369a6b605394bdd4be4633451be9 \
      issue \
      --vault-addr=https://${VAULT_DOMAIN_NAME} \
      --vault-token=$${VAULT_TOKEN} \
      --cluster-id=g8s \
      --common-name=${API_DOMAIN_NAME} \
      --ttl=8760h \
      --crt-file=/etc/kubernetes/ssl/worker-crt.pem \
      --key-file=/etc/kubernetes/ssl/worker-key.pem \
      --ca-file=/etc/kubernetes/ssl/worker-ca.pem

      [Install]
      WantedBy=multi-user.target
  - name: k8s-kubelet.service
    enabled: true
    contents: |
      [Unit]
      Description=k8s-kubelet
      StartLimitIntervalSec=0
      After=kubelet-certs.service
      Requires=kubelet-certs.service

      [Service]
      Restart=always
      RestartSec=0
      TimeoutStopSec=10
      EnvironmentFile=/etc/network-environment
      Environment="IMAGE=quay.io/giantswarm/hyperkube:v1.10.2"
      Environment="NAME=%p.service"
      Environment="NETWORK_CONFIG_CONTAINER="
      ExecStartPre=/usr/bin/docker pull $IMAGE
      ExecStartPre=-/usr/bin/docker stop -t 10 $NAME
      ExecStartPre=-/usr/bin/docker rm -f $NAME
      ExecStart=/bin/sh -c "/usr/bin/docker run --rm --pid=host --net=host --privileged=true \
      -v /:/rootfs:ro,rshared \
      -v /sys:/sys:ro \
      -v /dev:/dev:rw \
      -v /run/calico/:/run/calico/:rw \
      -v /run/docker/:/run/docker/:rw \
      -v /run/docker.sock:/run/docker.sock:rw \
      -v /usr/lib/os-release:/etc/os-release \
      -v /usr/share/ca-certificates/:/etc/ssl/certs \
      -v /var/lib/docker/:/var/lib/docker:rw,rshared \
      -v /var/lib/kubelet/:/var/lib/kubelet:rw,rshared \
      -v /var/log:/var/log:rw \
      -v /etc/kubernetes/ssl/:/etc/kubernetes/ssl/ \
      -v /etc/kubernetes/config/:/etc/kubernetes/config/ \
      -v /etc/cni/net.d/:/etc/cni/net.d/ \
      -v /opt/cni/bin/:/opt/cni/bin/ \
      -e ETCD_CA_CERT_FILE=/etc/kubernetes/ssl/etcd/client-ca.pem \
      -e ETCD_CERT_FILE=/etc/kubernetes/ssl/etcd/client-crt.pem \
      -e ETCD_KEY_FILE=/etc/kubernetes/ssl/etcd/client-key.pem \
      --name $NAME \
      $IMAGE \
      /hyperkube kubelet \
      --address=${DEFAULT_IPV4} \
      --port=10250 \
      --node-ip=${DEFAULT_IPV4} \
      --containerized \
      --enable-server \
      --logtostderr=true \
      --cloud-provider=azure \
      --cloud-config=/etc/kubernetes/config/azure.yaml \
      --machine-id-file=/rootfs/etc/machine-id \
      --cadvisor-port=4194 \
      --healthz-bind-address=${DEFAULT_IPV4} \
      --healthz-port=10248 \
      --cluster-dns=${K8S_DNS_IP} \
      --cluster-domain=cluster.local \
      --feature-gates=ExpandPersistentVolumes=true \
      --network-plugin=cni \
      --register-node=true \
      --allow-privileged=true \
      --kubeconfig=/etc/kubernetes/config/kubelet-kubeconfig.yaml \
      --node-labels="node-role.kubernetes.io/worker,role=worker,ip=${DEFAULT_IPV4}" \
      --v=2"
      ExecStop=-/usr/bin/docker stop -t 10 $NAME
      ExecStopPost=-/usr/bin/docker rm -f $NAME

      [Install]
      WantedBy=multi-user.target
storage:
  filesystems:
    - name: docker
      mount:
        device: /dev/sdc
        format: xfs
        wipe_filesystem: false
        label: docker
